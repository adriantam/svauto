#!/bin/sh
# Default configuration settings for PTSD package
# Do not edit this file. Edit rc.conf to override these.
#
# Copyright (C) by Sandvine Inc.

# If non-zero, put the ptsd in verbose mode.  Should only be used for
# debugging.
ptsd_debugLvl=0

# Allow override of SCDP behaviour.  Should only be used for debugging.
ptsd_noScdp=0

# Start ptsd by default
ptsd_run=yes

# The default multicast group to use for all incoming/outgoing SCDP messages 
scdp_mcast_group="239.0.1.0"

# The TTL to be used in all outgoing SCDP messages.
scdp_mcast_ttl=5

# The SCDP work interval determines how often the PTS will receive SCDP 
# notifications. 
scdp_work_interval=4

# By default, we set the scdp service interface to the motherboard map
# definition of the service
eval scdp_service=\$$PORT_${SERVICE_1}

# If it is necessary to interoperate with devices that issue non authenticated
# scdp messages, set this to 1.
scdp_disable_auth=0

#scdp_control=

# If PPE reports a load greater than or equal to this value, flows will not
# be diverted to that PPE.
ptsd_max_useful_load=100

# Specifies whether to always go deep into packet to find direction.
ptsd_alwaysFindDir=0

# p2p monitor compatability
svmon_p2pstats=yes
mon_run=no

# include wdtm and db defaults
#####included ../../include/rc.conf.default.db BEGIN #####
#!/bin/sh

# Minimum amount of time in seconds to wait before attempting to connect to
# the database after a disconnect
db_connection_retry_interval=5
# Minimum amount of time in seconds to wait before attempting to connect to
# the database after a connection attempt has failed
db_failed_connection_retry_interval=5
# Maximum amount of time in seconds to try to connect to the database
# before giving up and trying the next URI in the list (if available)
db_connection_timeout=3
# Interval in seconds between JMS connection keepalive messages.
# This is the length time it will take an idle PTS to discover
# its connection is down and try another broker in its URI list.
db_connection_ping_interval=30

# The default number of historical statistics that will be written each pass
maxConsecutiveStats=5000

# Space-separated list of URIs for SPB servers.
# This can just take hostnames/IP addresses in the simplest case,
# or it can take URIs e.g. ssl://spb.example.com:50000
spb_servers=""

# The default username/password for accessing the SPB services.
# The service username and password will be sent for every request.
spb_service_username=spbadmin
spb_service_password=sandvine

# The default username/password for connecting to the JMS broker. 
jms_connection_username=Administrator
jms_connection_password=_sandvine1

#
# Internal PDB Path Definitions.  Do not override these.
#
pdb_db_connection_retry_interval="dbClient.1.config.connectionRetryInterval"
pdb_db_failed_connection_retry_interval="dbClient.1.config.failedConnectionRetryInterval"
pdb_db_connection_timeout="dbClient.1.config.connectionTimeoutSec"
pdb_db_connection_ping_interval="dbClient.1.config.connectionPingIntervalSec"
pdb_db_enable_autocommit="dbClient.1.config.enableAutocommit"
pdb_db_server_side_prepare="dbClient.1.config.serverSidePrepare"
pdb_enableDatabaseWrites="dbClient.1.config.enableDatabaseWrites"
pdb_maxConsecutiveStats="dbClient.1.config.maxConsecutiveStats"
pdb_subscriber_database_writing_connection_uri="dbClient.1.10.1.URI.10451"
pdb_subscriber_database_connection_uri="dbClient.1.10.1.URI.10717"
pdb_subscriber_database_connection_retry_interval="dbClient.1.10.1.connectionRetryInterval.10717"
pdb_statistics_database_connection_uri="dbClient.1.10.1.URI.10450"
pdb_jms_connection_uri="dbClient.1.1000"
pdb_jms_connection_username="dbClient.1.config.connUsername"
pdb_jms_connection_password="dbClient.1.config.connPassword"
pdb_spb_service_username="dbClient.1.config.serviceUsername"
pdb_spb_service_password="dbClient.1.config.servicePassword"

# Added to store the actual spb address in debug table, so that 'show spb' 
#display the actual spb address and not the tunnel address
pdb_spb_servers="dbClient.1.debug.SpbAddress"
#####included ../../include/rc.conf.default.db END #####
#####included ../../include/rc.conf.default.wdtm BEGIN #####
#!/bin/sh
# Default configuration settings for all WDTM packages
# Do not edit this file. Edit rc.conf to override these.

# Filename for the Sandvine WDTM policy file.  This file contains Sandvine
# recommended rules.
# The contents of this file should never be modified
wdtm_policy_sandvine_file="/usr/local/sandvine/etc/policy.sandvine.conf"

# Filename for the cluster WDTM policy file.  All elements in the cluster
# will implement rules contained in this file
wdtm_policy_cluster_file="/usr/local/sandvine/etc/policy.cluster.conf"

# Filename for the local WDTM policy file.  Only this element will implement
# rules contained in this file
wdtm_policy_local_file="/usr/local/sandvine/etc/policy.local.conf"

# Filename for the Sandvine pattern file.  This file lists all of the known
# patterns (worms) that the WDTM can search for.  
# The contents of this file should never be modified
wdtm_pattern_sandvine_file="/usr/local/sandvine/etc/pattern.sandvine.conf"

# Minimum rule priority determines which rules will be enabled.  All rules 
# equal or below this value will be enabled. Increase the minimum priority
# to disable rules with high priority values.
# Set wdtm_minimum_rule_priority=0 to disable all rules. 
wdtm_minimum_rule_priority=1

# Due to the number of signature matches received from the internet, the
# matches will not be logged to the database by default in the interest of
# saving the database from unnecessary load caused by external traffic.
wdtm_disable_log_external_signature=true

# Default database update interval in seconds.  Default 900=15min.
wdtm_db_interval=900

#
# Internal PDB Path Definitions.  Do not override these.
#
# shared with everything
pdb_cluster_name="cluster.1.config.name"
pdb_sub_cluster_name="cluster.1.config.subName"

pdb_wdtm_policy_sandvine_file="wdtmPolicy.1.config.sandvinePolicyFile"
pdb_wdtm_policy_cluster_file="wdtmPolicy.1.config.clusterPolicyFile"
pdb_wdtm_policy_local_file="wdtmPolicy.1.config.localPolicyFile"
pdb_wdtm_pattern_sandvine_file="wdtmPolicy.1.config.sandvinePatternFile"
pdb_wdtm_minimum_rule_priority="wdtmPolicy.1.config.minimumRulePriority"
pdb_wdtm_db_interval="wdtmPolicy.1.config.statisticsInterval"
pdb_wdtm_db_connection_retry_interval="dbClient.1.config.connectionRetryInterval"
pdb_wdtm_stat_enable_autocommit="dbClient.1.config.enableAutocommit"
pdb_wdtm_disable_log_external_signature="wdtmPolicy.1.2.disableLogExtSignature"
#####included ../../include/rc.conf.default.wdtm END #####

# Set default port roles for 8210 and virtual PTS
if Is8210 || IsVirtual
then
    port_topology_defined=1
    SetPortRole 3 subscriber
    SetPortRole 4 internet
    SetPortRole 5 subscriber
    SetPortRole 6 internet
fi

# pdb paths to set path for subnet and policy rule files
pdb_ptsd_subnets="policyFiles.1.config.subnetFile"
ptsd_subnets="/usr/local/sandvine/etc/subnets.txt"
pdb_ptsd_domains="iso.org.dod.internet.private.enterprises.sandvine.cse.ptse1.devices.policyFiles.1.config.domainListFile"
ptsd_domains="/usr/local/sandvine/etc/domains.txt"
pdb_ptsd_policy="policyFiles.1.config.policyFile"
ptsd_policy="/usr/local/sandvine/etc/policy.conf"
pdb_max_number_subnets="policyFiles.1.config.maxNumberSubnets"
max_number_subnets=50000
pdb_show_package_error_details="policyFiles.1.config.showPackageErrorDetails"
show_package_error_details=false
pdb_domain_suffix_list_file="policyFiles.1.config.domainSuffixListFile"
domain_suffix_list_file="/usr/local/sandvine/etc/effective_tld_names.dat"

# Control load-time optimization of policies containing measurements based on flow statistics 
pdb_policy_optimize_flow_statistics="policy.1.config.optimization.optimizeFlowStats"
policy_optimize_flow_statistics=true

# Control load-time optimization of policy actions in end-of-flow policy runs 
pdb_policy_optimize_end_flow="policy.1.config.optimization.optimizeEndFlow"
policy_optimize_end_flow=true

# Control Initialization policy for shared policy table cursors
pdb_policy_lazy_init_shared_cursors="policy.1.config.optimization.lazilyInitializeSharedCursors"
policy_lazy_init_shared_cursors=false

pdb_cluster_name="cluster.1.config.name"
pdb_sub_cluster_name="cluster.1.config.subName"
pdb_cluster_stat_name="cluster.1.config.statName"
cluster_stat_name=""

pdb_max_shapers="shaping.1.config.maxShapers"
max_shapers=100
pdb_max_shaper_rows="shaping.1.config.maxPdbRows"
max_shaper_rows=100

pdb_max_measurements="measurements.1.config.maxMeasurements"
max_measurements=1024
pdb_max_measurement_rows="measurements.1.config.maxPdbRows"
max_measurement_rows=1024

pdb_unique_by_rows_clear_interval_ms="measurements.1.config.uniqueByRowsClearIntervalMS"
unique_by_rows_clear_interval_ms=60
pdb_unique_by_rows_to_clear_per_iter="measurements.1.config.uniqueByRowsToClearPerIter"
unique_by_rows_to_clear_per_iter=25

pdb_max_published_expressions="publishedExpressions.1.config.maxPublishedExpressions"
max_published_expressions=200
pdb_max_published_expression_rows="publishedExpressions.1.config.maxPdbRows"
max_published_expression_rows=200

pdb_max_limiter_rows="sessionManagement.1.config.maxPdbRows"
max_limiter_rows=1024
# pdb path to set the flag to turn off logging of stats if cluster name hasn't
# been changed from the default (SANDVINE-1).  By default, this flag is false,
# meaning the pts will not log stats until the cluster name has been changed.
pdb_db_log_default_cluster="dbClient.1.config.logDefaultCluster"
db_log_default_cluster="no"

# step learning used in ppe loadbalancing
pdb_loadbal_steplearn="divertHostMgr.1.config.steplearn"

# minimum threshold used in ppe loadbalancing
pdb_loadbal_minthreshold="divertHostMgr.1.config.minthreshold"

# maximum threshold used in ppe loadbalancing
pdb_loadbal_maxthreshold="divertHostMgr.1.config.maxthreshold"

# minimum number of ppe's used in loadbalancing filter calculation
pdb_loadbal_minppe="divertHostMgr.1.config.minppe"

# minimum number of pts's used in loadbalancing filter calculation
pdb_loadbal_minpts="divertHostMgr.1.config.minpts"

# enable loadbalancing filter
pdb_loadbal_filterenable="divertHostMgr.1.config.filterenable"

# The default stat logging interval in seconds for interface stats
pdb_ptsd_statLogInterval="portStats.1.config.portLogInterval"
ptsd_statLogInterval=900

# The default stat logging interval in seconds for demographic stats
pdb_ptsd_demographicLogInterval="demographicStats.1.config.demographicLogInterval"
ptsd_demographicLogInterval=900 

# The default publication interval for expression-based statistics
pdb_ptsd_publicationInterval="publishedExpressions.1.config.publicationInterval"
ptsd_publicationInterval=60

# The default publication interval for expression-based statistics
pdb_ptsd_histogramInterval="publishedExpressions.1.config.histogramInterval"
ptsd_histogramInterval=900

# The default publication interval for expression-based statistics
pdb_ptsd_histogramProtocolInterval="publishedExpressions.1.config.histogramProtocolInterval"
ptsd_histogramProtocolInterval=900

# If host counting is performed...
pdb_ptsd_demographicHostCounting="demographicStats.1.hostCounts.config.enableHostCounting"
ptsd_demographicHostCounting=true

# The default maximum number of hosts that the ptsd will keep track of
pdb_ptsd_demographicLogMaxHosts="demographicStats.1.hostCounts.config.maxHosts"
ptsd_demographicLogMaxHosts=$(( $(get_config_value MCD_TUNING_PTSD_MAX_DEMOGRAPHIC_LOG_HOSTS) / \
    $the_total_ptsd_instances ))

# The default stat logging interval in seconds for subscriber basic stats
pdb_ptsd_sub_basicLogInterval="subscriberStats.1.config.basicLogInterval"
ptsd_sub_basicLogInterval=3600 

# The default stat logging interval in seconds for subscriber protocol stats
pdb_ptsd_sub_protocolLogInterval="subscriberStats.1.config.protocolLogInterval"
ptsd_sub_protocolLogInterval=900 

# The default stat logging interval in seconds for subscriber peer stats
pdb_ptsd_sub_peerLogInterval="subscriberStats.1.config.peerLogInterval"
ptsd_sub_peerLogInterval=900 

# Filter out subscriber basic stats below both minimum TX Bytes and minimum RX 
# Bytes thresholds.  We only consider minimum RX Bytes threshold on statistics 
# where TX Bytes is below minimum threshold.
pdb_ptsd_sub_basicMinTxBytesFilter="subscriberStats.1.config.basicMinTxBytesFilter"
ptsd_sub_basicMinTxBytesFilter=0
pdb_ptsd_sub_basicMinRxBytesFilter="subscriberStats.1.config.basicMinRxBytesFilter"
ptsd_sub_basicMinRxBytesFilter=0

# The default subscriber database query interval is in seconds.
# This is the time interval in which the system will periodically
# send queries to the database to determine subscriber-IP mapping changes,
# subscriber-attribute mapping changes and attribute expiries.
#   - minimum value is 1 second
#   - maximum value is 86400 seconds (1 day)
#   - value of 0 would disable database querying for configurations
#     that do not have subscriber mappings
pdb_subscriber_query_interval="subscriberMap.1.config.queryInterval"
subscriber_query_interval=120

# The default subscriber database query offset is in seconds.
# This value is used to overlap the periodic queries in situations where
# some records are inserted at the boundary of the queries and are missed
# by the queries. For example, if the query interval is set to 10 seconds and
# the offset set to 1 second, this means that the next periodic database query will
# have a start time of 1 second before the end time of the previous query
# (i.e. the new query overlaps the previous query
# by 1 second to cover the boundary conditions).
#   - minimum value is 1 second
#   - maximum value is 86400 seconds (1 day)
pdb_subscriber_query_offset="subscriberMap.1.config.queryOffset"
subscriber_query_offset=1

# The default subscriber database query IP lookup limit is the number of 
# IPs that is looked up per query to the database.
# This value is used to specify the degree of 'batching' that is 
# desired for looking up the subscribers in the database.
# For example, if the limit is set to 500, this means that one lookup query
# to the database will request and return at most 500 subscribers
#   - minimum value is 1 
#   - maximum value is 50000
pdb_subscriber_query_ip_lookup_limit="subscriberMap.1.config.queryIPLookupLimit"
subscriber_query_ip_lookup_limit=4000

# The following two parameters work together to
# affect the rate of timing out subscribers.
#   - subscriber_timeout_interval_ms determines how often to check
#   - timeout_max_subscribers determines how many to look at each time
#   (The search continues where it left off previously)
#
# Subscriber timeout interval is in milliseconds.
#   - minimum value of 0 milliseconds
#   - maximum value of 10000 milliseconds (10 seconds)
#   - value of 0 would disable subscriber timeout (i.e. subscribers would 
#     never time out from the system which is not recommended)
pdb_subscriber_timeout_interval_ms="subscriberMap.1.config.timeoutIntervalMs"
subscriber_timeout_interval_ms=30

# The default maximum number of subscribers to visit in each timeout interval
# to determine if they have timed out or not.
#   - minimum value is 1 subscriber
#   - maximum value is 1000 subscribers
pdb_timeout_max_subscribers="subscriberMap.1.config.timeoutMaxSubscribers"
timeout_max_subscribers=30

# known_subscriber_lookup_timeout
#   - sets the time in seconds we wait before retrying a subscriber lookup
#     for an IP with active traffic
#   - minimum value is 1 second
#   - maximum value is 86400 seconds (24 hours)
pdb_known_subscriber_lookup_timeout="subscriberMap.1.config.knownSidLookupTimeout"
known_subscriber_lookup_timeout=1200

# The following two parameters are used to set the length of time before
# timing out a subscriber due to inactivity (i.e. no traffic from the 
# IP).
# 
# known_subscriber_timeout
#   - sets the time in seconds before a known subscriber
#     (i.e. an IP which we have associated to a subscriber)
#     is timed out and will require a new lookup to be sent 
#     to the database to determine the subscriber to IP association
#   - minimum value is 1 second
#   - maximum value is 86400 seconds (24 hours)
pdb_known_subscriber_timeout="subscriberMap.1.config.knownSidTimeout"
known_subscriber_timeout=1200

# subscriber_login_state_timeout
#   - sets the time in seconds before log-in state timeout
#   - minimum value is 1 second
#   - maximum value is 86400 seconds (24 hours)
pdb_subscriber_login_state_timeout="subscriberMap.1.config.sidLoginTimeout"
subscriber_login_state_timeout=30

# unknown_subscriber_timeout
#   - sets the time in seconds before an unknown subscriber
#     (i.e. an IP for which we have not associated to a subscriber but 
#      have requested for the mapping and are awaiting the results)
#     is timed out and another lookup request is sent to the database
#     to determine the subscriber to IP association
#   - minimum value is 1 second
#   - maximum value is 86400 seconds (24 hours)
pdb_unknown_subscriber_timeout="subscriberMap.1.config.unknownSidTimeout"
unknown_subscriber_timeout=120

# unknown_subscriber_timeout_max
#   - sets the maximum time in seconds before an unknown subscriber
#     (i.e. an IP for which we have not associated to a subscriber but 
#      have requested for the mapping and are awaiting the results)
#     is timed out and another lookup request is sent to the database
#     to determine the subscriber to IP association
#     lookup backoff is done between the values of the variable 
#     unknown_subscriber_timeout specified above and this one
#     backoff algorithm is by a factor of 2
#   - minimum value is 1 second
#   - maximum value is 86400 seconds (24 hours)
pdb_unknown_subscriber_timeout_max="subscriberMap.1.config.unknownSidTimeoutMax"
unknown_subscriber_timeout_max=32400

# The default maximum number of subscribers we keep state for in the system
# This value should not be modified unless there are system issues
# which require a reduction or increase in the number of subscribers
#   - minimum value is 0 subscribers
pdb_max_subscribers="subscriberMap.1.config.maxSubscribers"

# The default maximum number of NAT mappings we will keep stat for in the system
# - minimum 0 (unlimited)
# - max (2^32)-1
pdb_max_nat_mappings="subscriberMap.1.config.nat.maxEntries"

if IsVirtual; then
    if IsVirtual_Small
    then
        # VM < 1G => #subscribers=5k
        max_subscribers=5000
    elif IsVirtual_Medium
    then
        # 1G <= VM < 4G => #subscribers=50k
        max_subscribers=50000
    else # IsVirtual_Large
        # 4G <= VM => #subscribers=same as 24700
        max_subscribers=150000
    fi
else
    max_subscribers=$(( (($(get_config_value MCD_TUNING_PTSD_MAX_SUBS) * 11) / 10) / $the_total_ptsd_instances ))
fi

# We configure for maximum of 2.5x NAT mappings per sub
# Kind of wierd looking, but bash arithmetic doesn't support decimal numbers
max_nat_mappings=$(( (25 * $max_subscribers) / 10 ))

# Is NAT mapping enabled for this element?
pdb_nat_mapping_enabled="subscriberMap.1.config.nat.enabled"
nat_mapping_enabled="false"

# The default maximum number of subscriber-ip mapping requests we make at any
# given time.         
pdb_max_subscriber_concurrent_requests="subscriberMap.1.config.concurrentRequestsMax"
max_subscriber_concurrent_requests=5

# When a SID is to be deleted, this timeout extends the lifetime by a
# configurable amount in seconds.
# Range from 0 to 900 seconds.
pdb_delay_unmap_time="subscriberMap.1.config.delayUnmapTime"
delay_unmap_time=0

# When the ptsd is told to unmap a SID, it begins immediately to reevaluate
# the SID's flows. This timeout (in seconds) is the maximum delay
# before removing the subscriber.  Once the flows are reevaluated, the SID is
# removed, usually much sooner than this timeout, subject to delayUnmapTime.
# Range from 0 to 900 seconds.
pdb_delay_unmap_reeval_time="subscriberMap.1.config.delayUnmapReevalTime"
delay_unmap_reeval_time=120

# Number of Sid Unmap events we will delay at the same time.  If we are
# currently delaying >= this many events, any new Sid Unmap events we recieve
# will be unmapped immediately
pdb_max_delayed_unmaps="subscriberMap.1.config.maxDelayedUnmaps"
max_delayed_unmaps=5000

# Perform a subscriber lookup only if the IP has sent any data for the flow that
# would otherwise trigger a lookup.
# When set to true, a unidirectional flow TO a subscriber will not trigger a
# lookup - once data comes FROM the subscriber, lookup will occur
pdb_lookup_subs_only_on_send="subscriberMap.1.config.lookupOnlyOnSend"
lookup_subs_only_on_send="true"

# Perform a subscriber lookup on ended flows (at end-of-flow policy run)
# When set to true, subscriber lookups will happen for any flow-scope policy
# run, regardless of the state of the flow.  When set to 'false', lookups will
# not be issued for flow-scope policy runs when Flow.IsEnd is true
pdb_lookup_subs_at_end_of_flow="subscriberMap.1.config.lookupAtEndOfFlow"
lookup_subs_at_end_of_flow="false"

# Configuration follows for the subscriber lookup delay algorithm.  The
# algorithm operates in one of two modes:
# 1) 'static' mode - the value of the static delay is used as a delay for the
#                    first lookup of any IP address
# 2) 'dynamic' mode - This mode is driven by the number of IP lookups which are
#                     mapped by an IP assignment notification instead of a
#                     lookup response.
#                     If, in the update interval, more than rising threshold %
#                     of all lookups are mapped via notification, then increment
#                     the delay by step value.  If less than falling threshold %
#                     are mapped by notification, decrease the delay by step
#                     value.  Never increase the delay past the max.

pdb_subscriber_mapping_initial_lookup_delay="subscriberMap.1.config.lookupDelayAlgorithm.lookupDelayMode"
subscriber_mapping_initial_lookup_delay="static"

pdb_subscriber_mapping_lookup_delay_static_ms="subscriberMap.1.config.lookupDelayAlgorithm.staticLookupDelayMs"
subscriber_mapping_lookup_delay_static_ms="0"

pdb_subscriber_mapping_lookup_delay_step_value_ms="subscriberMap.1.config.lookupDelayAlgorithm.lookupDelayStepValueMs"
subscriber_mapping_lookup_delay_step_value_ms="500"

pdb_subscriber_mapping_lookup_delay_dynamic_max_ms="subscriberMap.1.config.lookupDelayAlgorithm.maxLookupDelayMs"
subscriber_mapping_lookup_delay_dynamic_max_ms="5000"

pdb_subscriber_mapping_lookup_delay_rising_threshold="subscriberMap.1.config.lookupDelayAlgorithm.risingLookupDelayThresholdPct"
subscriber_mapping_lookup_delay_rising_threshold="10"

pdb_subscriber_mapping_lookup_delay_falling_threshold="subscriberMap.1.config.lookupDelayAlgorithm.fallingLookupDelayThresholdPct"
subscriber_mapping_lookup_delay_falling_threshold="3"

pdb_subscriber_mapping_lookup_delay_update_interval_ms="subscriberMap.1.config.lookupDelayAlgorithm.lookupDelayUpdateIntervalMs"
subscriber_mapping_lookup_delay_update_interval_ms="5000"

# Number of SID lookups to skip when we first see traffic for a given IP.  This gives time
# for the IP Assignment Notification to arrive before we do an active query.
pdb_num_subscriber_lookups_to_skip="subscriberMap.1.config.numLookupsToSkip"
num_subscriber_lookups_to_skip=0

# Maximum number of times to lookup a SID before we give up and stop.  The SID will be
# maintained in the TryMap state once this number of unsuccessful lookups is reached, and 
# no more queries will be sent.
# Set to 0 for inifinite lookups.
pdb_max_subscriber_lookups="subscriberMap.1.config.maxLookups"
max_subscriber_lookups=0

# Maximum number of seconds to wait while querying an IP mapping before the mapping is "late" in
# arriving.
# If the IP is mapped before this threshold, subscriberMap.1.stats.ipsMappedOnTime is incremented; 
# otherwise subscriberMap.1.stats.ipsMappedLate is incremented
pdb_late_subscriber_mapping_timeout="subscriberMap.1.config.lateMappingTimeout"
late_subscriber_mapping_timeout="30"

# How often should we send a batch of set-attribute operations to the SPB?
# Value is in milliseconds
#   - minimum value is 1 second
#   - maximum value is 60 seconds
pdb_sub_attribute_batch_interval="subscriberMap.1.config.attributeBatchInterval"
sub_attribute_batch_interval="300"

# Maximum number of attributes to send to the SPB in a batch of set-attribute
# operations.
#   - minimum value is 1 attribute per message
#   - maximum value is 50000 attributes per message
pdb_sub_attribute_batch_size="subscriberMap.1.config.modifySubAttributesLimit"
sub_attribute_batch_size="4000"

# If true, IP Assignment (login) notifications cause the SidRecord
# to immediately become MAPPED and available to policy.
# If false, these notifications cause the SidRecord to go into the
# LOGIN state, and will only become available to policy when activity is seen
# for the IP (ie. traffic on PTS, explicit policy access on SDE)
# DEFAULT: true
sid_immediately_map_login_events="true"
pdb_sid_immediately_map_login_events="subscriberMap.1.config.immediatelyMapLoginNotifications"

# Specify the version of the subscriber notification API to be used for
# receiving subscriber notifications (ip assignments, attribute updates, etc.)
# Valid choices are:
#    1 (represents the API used prior to PTS 5.6)
#    2 (represents the API introduced in PTS 5.6)
# The default is to use 2
pdb_spb_api_version="subscriberDatabase.1.config.spbSubscriberApiVersion"
spb_api_version="2"

# This variable is left only for old test (e.g. PTSE/stats/user).
# Not needed anymore. It's ptsm who allocated the region (sysctl-configurable).
# Ptsd can just limit the number it will use (<= the actual value).
# 0 means "use all".
ptsd_subscriberRegionSize=0

# The maximum time to wait for BGP update messages, in seconds.
# The PTS will wait until it receives update messages for every AS number
# specified in subnets.txt, or until this hold off period expires. 
# If zero, the PTS will wait indefinitely.
pdb_svbgp_holdoff="svbgp.1.config.holdoff"
svbgp_holdoff=20

#When BGPD goes down and comes back online, the subnets that are learnt previously
#are set to stale. If BGPClient (PTSD/CND) does not receive an update for a given
#subnet, it will be cleared after this timeout
#A side effect of this feature: When the BGPD comes back online, if its connection 
#with peer router does not establish within this timeout, all the entries in 
#PTSD will be cleared off.
#Hence it's a trade off between, how fast we should clear a stale subnet and
#the max delay taken to reconnect with the Router
pdb_svbgp_staleSubnetTimeout="svbgp.1.config.staleSubnetTimeout"
svbgp_staleSubnetTimeout=300

# enablePortDetection controls whether port-based detection is allowed.  
# Even when turned on, port-based detection is only used as a last resort 
# when packet inspection is unable to identify a protocol.  The problem is
# that port scans, which send a small amount of unidentifiable traffic to 
# each port at an IP address, will cause the port detection algorithm to 
# count the traffic incorrectly.  This variable, which defaults to "on" 
# can be used to turn off this feature.  This variable can be adjusted 
# in the PDB on the fly without reloading ptsd. 
pdb_enablePortDetection="protocolDetector.1.config.enablePortDetection"
enablePortDetection=yes

# When port detection is turned on, by default all ports will be tested 
# for well known ports when counting traffic.  This option controls 
# whether the PTS should only match ports up to and including a specified
# port number.  Originally this value defaulted to 65535 (inspect all ports),
# however in order to reduce false positives resulting from port based 
# detection, this value is now configured to be 1024 by default.
# This variable can be adjusted in the PDB on the fly without reloading 
# ptsd.
pdb_onlyDetectUpToPort="protocolDetector.1.config.onlyDetectUpToPort"
onlyDetectUpToPort=1024

pdb_svbgp_log_updates="svbgp.1.config.logUpdates"
svbgp_log_updates=false

#broadCastSidEvents controls whether a SidEvent gets broadcast to all
#PPUs or just the PPU assigned to that Sid.
#If true then SidEvents are broadcast to all PPUs
#If false then SidEvent is routed to correct PPU and if no PPU is assigned
#to the Sid then the event is dropped.
pdb_broadcastSidEvents="sidQueryEngine.1.config.broadcastSidEvents"
broadcastSidEvents=false

# Tracker defaults and pdb paths (from the monitor's default file)
pdb_trackUnknownProviders="trafficMonitor.1.config.voip.trackUnknownProviders"
pdb_trackUnknownProvidersPdb="trafficMonitor.1.config.voip.trackUnknownProvidersPdb"
pdb_maxUnknownProviders="trafficMonitor.1.config.voip.maxUnknownProviders"
pdb_providersTable="trafficMonitor.1.config.voip.providersTable"
trackUnknownProvidersPdb=1


# Default maximum number of unknown providers to store in the PDB
maxUnknownProviders=1000

pdb_ptsd_enable_tcp_payload_recognition="ptsd.1.config.tcpPayloadRecognitionEnabled" 
ptsd_enable_tcp_payload_recognition=true

pdb_ptsd_enable_udp_payload_recognition="ptsd.1.config.udpPayloadRecognitionEnabled" 
ptsd_enable_udp_payload_recognition=true

# the CIM server is required to support the send_event action
cim_servers="localCimom"
pdb_cim_servers="cimServer.1.cimServerTable"

event_retry_interval=10
event_pts_queue_size=1000000
event_cpm_queue_size=1000
event_action_stream_timeout=86400
event_host_sequence_timeout=86400

# The default pts cimom-polling interval is 10 minutes.  
# Beware that we could drop events for at most
# this interval if the cimom goes down
event_cimom_polling_interval=600

pdb_event_retry_interval="policy.1.config.eventConfig.retryInterval"
pdb_event_pts_queue_size="policy.1.config.eventConfig.ptsQueueSize"
pdb_event_cpm_queue_size="policy.1.config.eventConfig.cpmQueueSize"
pdb_event_action_stream_timeout="policy.1.config.eventConfig.actionStreamTimeout"
pdb_event_host_sequence_timeout="policy.1.config.eventConfig.hostSequenceTimeout"
pdb_event_cimom_polling_interval="policy.1.config.eventConfig.cimomPollingInterval"

# Enable/disable immediate actions. If true, applicable actions, such as "set",
# will be executed immediately upon being encountered as opposed to after all
# conditions are evaluated.
pdb_enable_immediate_actions="policy.1.config.enableImmediateActions"
enable_immediate_actions=true



# PTS Mitigation Actions
actions_max_actions=1000
actions_max_timeout_seconds=3600
actions_log_wdtm_measurements=true

pdb_actions_max_actions="ptsActions.1.config.maxActions"
pdb_actions_max_timeout_seconds="ptsActions.1.config.maxTimeoutSeconds"
pdb_actions_log_wdtm_measurements="ptsActions.1.config.logWdtmMeasurements"


# Enable/Disable real time stats by default. This overrides subscriber attribute
# value for real time stats.
pdb_real_time_stats_enabled="realTimeStats.1.config.enable"
real_time_stats_enabled=true

# QinQ
# Which QinQ ethertype should be used for the outter service vlan tag.
# 0x88a8 is the standard.
# 0x9100 is the deprecated but commonly used non-standard.
# 0x9200, 0x9300 are supported by some equipment (not supported by sv at this time).
pdb_qinq_ethertype="ptsm.1.config.qinqEthertype"
qinq_ethertype=0x88a8

# Force the ptsm to send TCP SYN packets to the Daemon for actioning
# independent of the Wdtm module.
pdb_force_syn_to_daemon="ptsm.1.config.forceSynToDaemon"
force_syn_to_daemon=false

# Regarless of the setting of other variables to control the sending of
# TCP SYN packets to the daemon (including forceSynToDaemon), this variable
# acts as the master control for SYN packet handling behaviour. If it is set
# to true, then all Syn packets will not be sent up to the daemon. If it is
# set to false, then the other variables take precedence.
pdb_suppress_syn_to_daemon="ptsm.1.config.suppressSynToDaemon"
suppress_syn_to_daemon=false

# Allow PTS to divert flow when replay_safe = false and client has already transmitted
# non TCP handshake packet to server
pdb_allow_divert_non_tcp_handshake="ptsm.1.config.allowDivertWithNonTCPHandshake"
allow_divert_non_tcp_handshake=true

# AFCP configuration setion
# the keepalive destination port is in the keep alive destination table
# and the following default values forces the PTS to find one of the data 
# interface mac as the system mac, control or service port IP as system IP
afcp_protocol_version=1
afcp_authentication=0
afcp_system_id=123
afcp_system_interface_index=1
afcp_keepalive_interval=10
afcp_keepalive_source_port=16666
afcp_flow_notify_enabled=2
afcp_records_per_flow_notify=30
afcp_flow_notify_holdoff_seconds=2
afcp_resend_holdoff_seconds=3
afcp_bypassed_flow_timeout=900
afcp_flow_notify_source_port=17777
afcp_flow_statistics_destination_port=18888
ether_address_swap_enabled=2
layer2_learning_enabled=2

# This points to the AFCP keep alive configuration table
pdb_afcp_protocol_version="flowSignalingProtocol/1/config/applicationFlowControl/protocolVersion"
pdb_afcp_authentication="flowSignalingProtocol/1/config/applicationFlowControl/authentication"
pdb_afcp_system_id="flowSignalingProtocol/1/config/applicationFlowControl/systemId"
pdb_afcp_system_interface_index="flowSignalingProtocol/1/config/applicationFlowControl/ifIndex"
pdb_afcp_keepalive_interval="flowSignalingProtocol/1/config/applicationFlowControl/keepalive/messageInterval"
pdb_afcp_keepalive_source_port="flowSignalingProtocol/1/config/applicationFlowControl/keepalive/localPort"
pdb_afcp_flow_notify_enabled="flowSignalingProtocol/1/config/applicationFlowControl/notify/enabled"
pdb_afcp_records_per_flow_notify="flowSignalingProtocol/1/config/applicationFlowControl/notify/maximumRecordsPerNotify"
pdb_afcp_flow_notify_holdoff_seconds="flowSignalingProtocol/1/config/applicationFlowControl/notify/notifyHoldoffSeconds"
pdb_afcp_resend_holdoff_seconds="flowSignalingProtocol/1/config/applicationFlowControl/notify/resendHoldoffSeconds"
pdb_afcp_bypassed_flow_timeout="flowSignalingProtocol/1/config/applicationFlowControl/notify/bypassedFlowTimeout"
pdb_afcp_flow_notify_source_port="flowSignalingProtocol/1/config/applicationFlowControl/notify/localPort"
pdb_afcp_flow_statistics_destination_port="flowSignalingProtocol/1/config/applicationFlowControl/statsMessage/localPort"
pdb_ether_address_swap_enabled="flowSignalingProtocol/1/debug/applicationFlowControl/etherAddressSwapping"
pdb_layer2_learning_enabled="flowSignalingProtocol/1/debug/applicationFlowControl/layer2Learning"
pdb_afcp_flow_notify_egress_port="flowSignalingProtocol/1/debug/applicationFlowControl/flowNotifyEgressPort"

# This points to the AFCP keep alive configuration table
# See the file rc.conf.afcp.sample for example of how to set the value
# into this table
afcp_keepalive_dst=""
pdb_afcp_keepalive_dst="flowSignalingProtocol/1/config/applicationFlowControl/keepalive/destinationTable"
# This points to the AFCP notify destination IP lookup table
afcp_flow_notify_dst=""
pdb_afcp_flow_notify_dst="flowSignalingProtocol/1/config/applicationFlowControl/notify/destinationTable"

# This variable enables the DPI of traffic inside L2TP tunnel or ip in ip 
# tunnel when it is set to l2tp or ipip respectively 
skip_IP_mode=""
pdb_skip_IP_mode="ptsm/1/config/skipIpMode"

# This variable will disable attempted reassembly of IP fragments when set to "no".
# If set to "yes" it will enable reassembly (although tunneling may disable it).
inspect_ipfragments=yes
pdb_inspect_ipfragments="ptsm/1/config/inspectIpFragments"

# This variable will enable extrapolated counting for fragmented tunnel IP packets. 
# If set to "yes", counting will include extrapolation based on IP length in the first fragment; 
# if set to "no", counting will only include the actual size of the first fragment. 
tunnel_fragment_extrapolation_enabled=no
pdb_tunnel_fragment_extrapolation_enabled="ptsm/1/config/enableExtrapolatedCounting"

# This variable is used to set maximum inner-ip payload length allowed in case
# of extrapolated counting. This is used to safe-guard against bogus packet.
tunnel_fragment_extrapolation_max_ip_packet_size=1600
pdb_tunnel_fragment_extrapolation_max_ip_packet_size="ptsm/1/config/maximumExtrapolatedIPPacket"

# This variable causes the PTSD to _NOT_ count specific header values
# you can list more than one variable here. ie: "ether fcs"
# possible values include:
# ether: don't count ether header
# tunnel: don't count any tunnel header bytes
# padding: don't count any ethernet padding
# fcs: don't count the ethernet frame checksum
# min64bytes: don't extend the packet size up to 64 bytes
skip_header_counting_mode="padding min64bytes"
pdb_skip_header_counting_mode="ptsm/1/config/skipHeaderCountingMode"

# This variable enables the DPI of traffic inside pseudowire 
# available modes are eompls_tagged, eompls_raw. The mpls inspection
# must be enabled before this variable can take effect
inspect_pseudowire_mode=""
pdb_inspect_pseudowire_mode="ptsm/1/config/inspectPseudowireMode"


# each module gets the full rate of a shaper or a session limiter
# when this value is set to false. When it is true, each module just gets
# a fraction of the total shaper rate.
module_sharing_shaper_limiter_rate=true
pdb_module_sharing_shaper_limiter_rate="ptsd/1/config/moduleSharingShaperLimiterRates"

# When this value is true we end all the flows of a subscriber
# on subscriber log out. When it is false we run policy for
# the flows and subscriber on subscriber logout.
end_flows_on_subscriber_logout="false"
pdb_end_flows_on_subscriber_logout="ptsd/1/config/endFlowsOnSubscriberLogout"

# AES key for decrypting map definition files
maps_aes_key="b0db7bedd5f64768baa9dd23e12335c0"
pdb_maps_aes_key="policyMaps/1/config/aesKeyName"

# maximum entries that can be stored in policy maps.
pdb_maps_max_entries="policyMaps.1.config.maxMapEntries"
maps_max_entries=$(get_config_value MCD_TUNING_PTSD_MAX_MAPS_ENTRIES)

# maximum memory (in bytes) that can be used to store policy maps.
pdb_maps_max_size="policyMaps.1.config.maxMapSize"
maps_max_size=$(get_config_value MCD_TUNING_PTSD_MAX_MAPS_SIZE)

# Define the path to the L3 hairpin destination MAC of all the 
# possible pts8210 ports. Default value is empty
port_3_3_destMAC=""
port_3_4_destMAC=""
port_3_5_destMAC=""
port_3_6_destMAC=""
port_3_7_destMAC=""
port_3_8_destMAC=""
port_3_9_destMAC=""
port_3_10_destMAC=""

pdb_port_3_3_destMAC="portTopology.1.bridgeGroup.portTable.1.destMAC.3.3"
pdb_port_3_4_destMAC="portTopology.1.bridgeGroup.portTable.1.destMAC.3.4"
pdb_port_3_5_destMAC="portTopology.1.bridgeGroup.portTable.1.destMAC.3.5"
pdb_port_3_6_destMAC="portTopology.1.bridgeGroup.portTable.1.destMAC.3.6"
pdb_port_3_7_destMAC="portTopology.1.bridgeGroup.portTable.1.destMAC.3.7"
pdb_port_3_8_destMAC="portTopology.1.bridgeGroup.portTable.1.destMAC.3.8"
pdb_port_3_9_destMAC="portTopology.1.bridgeGroup.portTable.1.destMAC.3.9"
pdb_port_3_10_destMAC="portTopology.1.bridgeGroup.portTable.1.destMAC.3.10"


# Method for setting the L3 hairpin destination mac address
# SetL3HairpinDestinationMac <port> <destmac>
# <destmac> can be "none" to explicitly set a null destmac (the default)
SetL3HairpinDestinationMac()
{
    if ! Is8210 && ! IsVirtual
    then
        SetL3HairpinDestinationMac14K "$@"
        return
    fi

    if [ $# -lt 2 ]
    then
        log "SetL3HairpinDestinationMac: port and destination mac (or none) are required" ptsd MCD_LOG_LBC_PORT_DESTMAC_REQUIRED LOG_ERR SetL3HairpinDestinationMac
        rc_conf_error_occurred=1
        return
    fi

    local mac="$2"
    if [ "$mac" = "none" ]
    then
        mac=""
    fi

    eval port_3_${1}_destMAC="$mac"
}

# Do we want to track external addresses arriving on subscriber-marked ports?
pdb_track_external_addresses="portTopology.1.config.trackExternalAddressesOnInternalPorts"
track_external_addresses="true"

# Do we want to avoid the port-role sanity checking that causes the
# error "Data interfaces have an invalid configuration of port roles."
pdb_ignorePortSideConfigurationConstraints="portTopology.1.config.ignorePortSideConfigurationConstraints"
ignorePortSideConfigurationConstraints="false"


# Controls for the default numbers of L5 reaseembly buffers
pdb_max_small_reassembly_buffers="flowReassembly.1.config.smallBuffers"
pdb_max_medium_reassembly_buffers="flowReassembly.1.config.mediumBuffers"
pdb_max_large_reassembly_buffers="flowReassembly.1.config.largeBuffers"
pdb_flow_reassembly_small_buffers="flowReassembly.1.config.smallBuffers"
pdb_flow_reassembly_medium_buffers="flowReassembly.1.config.mediumBuffers"
pdb_flow_reassembly_large_buffers="flowReassembly.1.config.largeBuffers"
flow_reassembly_small_buffers=$(get_config_value MCD_TUNING_PTSD_NUM_FLOW_REASSEMBLY_SMALL_BUFFERS)
flow_reassembly_medium_buffers=256
flow_reassembly_large_buffers=64


# Sets value of shaper's maximum queue weight
pdb_shaper_max_queue_weight="ptsm/1/config/shaperMaxQueueWeight"
# These two variables deprecate the onces in rc.conf.default.sfcd
# Session Management now works on both the 14k and 8210.
# session_management_enable=On/Off
# session_management_nexthop_router=abc.def.ghi.jkl
# then "svreload" to commit the new configuration 
pdb_session_management_enable="sessionManagement.1.2.100.1"
pdb_session_management_nexthop_router="sessionManagement.1.2.100.2"

# the number of seconds to wait until a policy package starts
pdb_seconds_until_package_starts="policyFiles.1.2.7"

# tcp/udp recognition enable/disable
pdb_tcp_Payload_Recognition_Enabled="ptsd.1.2.tcpPayloadRecognitionEnabled"
tcp_Payload_Recognition_Enabled="true"
pdb_udp_Payload_Recognition_Enabled="ptsd.1.2.udpPayloadRecognitionEnabled"
udp_Payload_Recognition_Enabled="true"  

# The maximum number of prime flow classifications allowed
pdb_max_primed_flow_classifications="flowClassification.1.config.maxPrimedFlowClassifications"

max_primed_flow_classifications=$(( $(get_config_value MCD_TUNING_PTSD_MAX_PRIMED_FLOW_CLASS) / \
    $the_total_ptsd_instances ))

# The maximum number of flow classifications per container
pdb_max_classification_container_size="flowClassification.1.config.maxClassificationContainerSize"
#max_classification_container_size=100

DIAM_DICTRF_FILE="/usr/local/sandvine/etc/diam_dictionary.xml"
DIAM_CONFIG_FILE="/usr/local/sandvine/etc/diam_config.xml"
DIAM_PEER_FILE="/usr/local/sandvine/etc/diam_peer_config.xml"

# policy table configurations

# maximum total number of rows of all the tables combined
pdb_tables_max_total_rows="tables.1.config.maxTotalRows"
tables_max_total_rows=$(( $(get_config_value MCD_TUNING_PTSD_TABLE_MAX_TOTAL_ROWS) / \
    $the_total_ptsd_instances ))

# maximum total row bytes of all the tables combined
pdb_tables_max_total_bytes="tables.1.config.maxTotalBytes"
tables_max_total_bytes=$(( 524288 * $tables_max_total_rows / 1000 ))

# maximum number of rows garbage collected at once
pdb_tables_max_rows_per_garbage_collection="tables.1.config.maxRowsPerGarbageCollection"
tables_max_rows_per_garbage_collection=$(( $tables_max_total_rows / 10 ))

# maximum number of policy tables can be defined
pdb_tables_max_tables="tables.1.config.maxTables"
tables_max_tables=1000

# minimum number of deleted rows that triggers a garbage collection run
pdb_tables_min_garbage_collection_rows="tables.1.config.minRowsGarbageCollection"
tables_min_garbage_collection_rows=20

# the maximum number of events a policy subsystem may process per second
pdb_policy_subsystems_subsystemEventsPerSecond="policySubsystems.1.2.subsystemEventsPerSecond"

# the default is 5000 events per second per subsystem
policy_subsystems_subsystemEventsPerSecond=5000


# The primeflow timeout used by the match by domain feature
pdb_match_by_domain_timeout="matchByDomain.1.config.maxiumumTimeToLiveSeconds"
match_by_domain_timeout=900

# Controls how the Match by Domain feature uses the trusted nameservers
# defined in matchbydomain.txt
# 0 - Only attempt to match from trusted nameservers
# 1 - Only allow an allClient match for trusted nameservers
# 2 - Treat all responses as if sent from a trusted nameserver
pdb_match_by_domain_nameserver_behaviour="matchByDomain.1.config.untrustedNameserverMatchAgressiveness"
match_by_domain_nameserver_behaviour=2

# The following variables configure the PTSD bridging alarm.  The first variable will
# enable/disable the alarm, and the second variable configured the maximum length of
# time the PTSD can bridge packets before alarming (in seconds)
pdb_bridge_mode_timeout_enabled="ptsd.1.config.bridgeModeTimeoutEnabled"
bridge_mode_timeout_enabled=true
pdb_bridge_mode_timeout="ptsd.1.config.bridgeModeTimeout"
bridge_mode_timeout=300

# Number of detected high usage IPs to be sent per collection interval to the CLB.  Valid
# range 1-10
pdb_ptsd_num_high_usage_ips_to_send="ptsd.1.config.highUsageIpMonitor.numHighUsageIpsToSend"
ptsd_num_high_usage_ips_to_send=10

# clear all the pdb vlan label first
ConfigDefaultVlanLabelFunction()
{
    # Since there are many vlans, we cannot clear them one by one.  
    # Instead, issue the clear command
    eval pdb_ord_vlan_label_clear_2_1="networkUtilities.1.vlanLabelMgr.config.clearVlanEntries"
    eval ord_vlan_label_clear_2_1="1"
    eval numVlanLabel=0

}

ConfigDefaultVlanLabelFunction

# parameter list:
# param 1 is the vlan
# param 2 is the label
SetVlanLabelActual()
{
    numVlanLabel=$(($numVlanLabel + 1))
    # we have to add numVlanLabel first as pdb start with 1
    eval pdb_ord_vlan_label_vlan_3_${numVlanLabel}="networkUtilities.1.vlanLabelMgr.vlanLabelTable.1.assignedVlan.$numVlanLabel"
    eval ord_vlan_label_vlan_3_${numVlanLabel}=$1
    eval pdb_ord_vlan_label_label_3_${numVlanLabel}="networkUtilities.1.vlanLabelMgr.vlanLabelTable.1.assignedLabel.$numVlanLabel"
    eval ord_vlan_label_label_3_${numVlanLabel}=$2

}

# external interface to do vlan setting - it will call SetVlanLabelActual
# parameter list:
# param 1 is the vlan
# param 2 is the label
SetVlanLabel()
{
    if [ $# -lt 2 ]
    then
        log "SetVlanLabel: vlan number and label are required" lbcd MCD_LOG_BLANK LOG_ERR
        rc_conf_error_occurred=1
        return
    fi


    if ! CheckVlanRange $1 
    then 
        log "Error in rc.conf: SetVlanLabel - vlan $1 must be of the range of $(ReturnValidVlanRange)" lbcd MCD_LOG_BLANK LOG_ERR
        rc_conf_error_occurred=1
        return
    fi
    
    if [ $numVlanLabel -gt 3000 ]
    then 
        log "Error in rc.conf: Too many SetVlanLabel calls" lbcd MCD_LOG_BLANK LOG_ERR
        rc_conf_error_occurred=1
        return
    fi

    SetVlanLabelActual $1 $2
}


# The maximum allowed TTL in milliseconds for sending synchronous messages
# to the spb can be configured using 
# this variable. range 0 - 86400000(1 day)
# set to zero for no expiry(infinite)
pdb_sync_spb_max_ttl_msec="connectionInfo/1/config/syncMaxTTL"
sync_spb_max_ttl_msec=86400000


# Allow unmapped subscriber network aggregation to be enabled/disabled
pdb_unmapped_subscriber_aggregation_enabled="subscriberMap.1.config.unmappedSubscriberNetworkTracking"
unmapped_subscriber_aggregation_enabled="true"
# Allow unmapped subscriber network aggregation to be enabled/disabled
pdb_unmapped_subscriber_network_size="subscriberMap.1.config.unmappedSubscriberNetworkSize"
unmapped_subscriber_network_size="24"
pdb_unmapped_subscriber_network_size_IPv6="subscriberMap.1.config.unmappedSubscriberNetworkSizeIPv6"
unmapped_subscriber_network_size_IPv6="56"

# Sets the variables that control limits on the number of unique by 
# subscriber measurements. 
# One parameter: the new limit.
SetMaxUniqueBySubscriberMeasurements()
{
    if [ $1 -ge 32 -a $1 -le 256 ]
    then
        eval pdb_max_custom_sum_fields="statsIntegration.1.config.maxCustomSumFields"
        eval max_custom_sum_fields=$1

        eval pdb_max_published_unique_by_measurements="measurements.1.config.maxUniqueByTableMeasurements"
        eval max_published_unique_by_measurements=$1
    else
        log "Error in rc.conf: SetMaxUniqueBySubscriberMeasurements must be in range 32..256" ptsd MCD_LOG_BLANK LOG_ERR
        rc_conf_error_occurred=1
    fi
}

SetMaxUniqueBySubscriberMeasurements 64

# Flow Reporting configuration
# Maximum number of flows to visit per IP
pdb_ptsd_sub_flowReportingMaximumFlows="ptsd.1.config.maxFlowVisitors"
ptsd_sub_flowReportingMaximumFlows=500 

# Enable or disable module interface drop monitoring.   
pdb_module_interface_monitoring_enabled="ptsd.1.config.moduleInterfaceMonitor.moduleMonitorEnabled"
module_interface_monitoring_enabled="false"

# Interval between successive module interface drop monitoring cycles, in milliseconds
pdb_module_interface_monitor_interval_msec="ptsd.1.config.moduleInterfaceMonitor.monitorIntervalMSec"
module_interface_monitor_interval_msec=2000

# Threshold for number of module interface packet drops required to trigger drop detection.
module_interface_packet_drop_threshold=50
pdb_module_interface_packet_drop_threshold="ptsd.1.config.moduleInterfaceMonitor.dropCountThreshold"

# PolicyController configuration
if Is24k || Is22k || Is14k || Is32k; then
    controller_client_config_memory=50000000
else
    controller_client_config_memory=5000000
fi
# Number of requests from the controller server to process per thread run
controller_client_config_requests_per_run=200
# Number of metrics from policy to process per thread run
controller_client_config_metrics_per_run=1200
# Number of microseconds to sleep per thread run
controller_client_config_thread_sleep_interval=1000
# The size of the client request ring before (incoming requests from server)
controller_client_config_ring_buffer_requests=5500

# The size of the policy ring buffer (metrics read from policy, sent to controller client)
controller_client_config_ring_buffer_policy=5500
# Number of sample intervals that a unique by instance has to have no new metrics before
# being cleaned
controller_client_config_timeout=2
pdb_controller_client_config_requests_per_run="controller.1.config.maxRequestsPerRun"
pdb_controller_client_config_metrics_per_run="controller.1.config.maxMetricsPerRun"
pdb_controller_client_config_thread_sleep_interval="controller.1.config.clientSleepDurationUs"
pdb_controller_client_config_memory="controller.1.config.maxMemoryClient"
pdb_controller_client_config_timeout="controller.1.config.instanceIntervalLifeSpan"
pdb_controller_client_config_ring_buffer_policy="controller.1.config.clientPolicyRingBufferSize"
pdb_controller_client_config_ring_buffer_requests="controller.1.config.clientRequestRingBufferSize"

# default session qualified site mappings
pdb_sessionQualifierConfigRulesTable="sessionQualifiers.1.config.sessionQualifierConfigRules"
sessionQualifierConfigRulesTable=""

pdb_session_qualifiers_cluster_number="sessionQualifiers.1.config.defaultSite"
session_qualifiers_cluster_number="0"

pdb_session_qualifiers_mode="sessionQualifiers.1.config.mode"
session_qualifiers_mode="none"

pdb_session_qualifiers_warn_ip_policy="sessionQualifiers.1.config.warnPolicyUniqueIpEnabled"
session_qualifiers_warn_ip_policy="true"

# Helper function used by AddSessionQualifierSiteMapping and
# AddSessionQualifierBridgeGroupSiteMapping.
#
# args:
#   1 - bridgeGroup (numeric or the word 'any')
#   2 - client-tag vlan (numeric or the word 'any')
#   3 - site (numeric)
#   4 - service-tag vlan (numeric or the word 'any')
#
# Note that the session qualifier module currently does not support
# rules where both bridgeGroup *AND* vlans are set (ie, currently
# one must be specified as "any")
AddSessionQualifierSetVlanBridgeGroupToSiteMapping()
{
    # Table row keys
    local bridgegroup="$1"
    local svlan="$4"
    local cvlan="$2"

    # Table row value
    local site="$3"

    # Construct a unique table row name based on the keys - all bash environment
    # variables for this table row will contain this string
    local rowName="sqbg${bridgegroup}cv${cvlan}sv${svlan}"

    # Read the current configured value for this Bridge-group/c-vlan/s-vlan
    # tuple from the environment.
    local currentConfiguredSite=$(eval echo \$${rowName}__site)

    if [ -n "$currentConfiguredSite" ]; then

        # This BG/CVLAN/SVLAN tuple is already configured to a site
        # If the site's the same, let's just ignore it
        if [ "$currentConfiguredSite" -eq ${site} ]; then
            return 0
        fi

        # Duplicate defined with differing site - error out
        return 1
    fi

    # Add the new row into the list of rows
    if [ -z "$sessionQualifierConfigRulesTable" ]; then
        sessionQualifierConfigRulesTable="$rowName"
    else
        sessionQualifierConfigRulesTable="$sessionQualifierConfigRulesTable $rowName"
    fi

    # Set all the fields in the table row
    eval ${rowName}__bridgeGroup="${bridgegroup}"
    eval ${rowName}__serviceVlan="${svlan}"
    eval ${rowName}__clientVlan="${cvlan}"

    eval ${rowName}__site="${site}"

    return 0
}

# Called by CLI 'set config service session-qualifier vlan'
#
# args:
#   1 - client-tag vlan (numeric 0..4095)
#   2 - site
AddSessionQualifierSiteMapping()
{
    local cvlan="$1"
    local site="$2"

    # "Old" (non-QinQ) session qualifier vlan rules should force svlan = 0 (by requirement)
    local svlan="0"

    if [ "$cvlan" = "any" ]; then
        # Will log "Session qualifier rule (vlan `$cvlan` site `$site`) is not supported"
        log "Cannot use 'any' as vlan" ptsd MCD_LOG_SQ_INVALID_VLAN_RULE LOG_ERR "$cvlan" "$site"
        rc_conf_error_occurred=1
        return
    fi

    AddSessionQualifierSetVlanBridgeGroupToSiteMapping "any" "$cvlan" "$site" "$svlan"

    if [ $? -ne 0 ]; then
        # Will log "Session qualifier rule (vlan $cvlan site $site) is a duplicate rule"
        log "Duplicate rule detected" ptsd MCD_LOG_SQ_DUPLICATE_VLAN_RULE LOG_ERR "$cvlan" "$site"
        rc_conf_error_occurred=1
        return
    fi
}

# Called by CLI 'set config service session-qualifier s-vlan'
#
# args:
#   1 - service-tag vlan (numeric 0..4095 or the word 'any')
#   2 - client-tag vlan (numeric 0..4095 or the word 'any')
#   3 - site
#
AddQinQSessionQualifierSiteMapping()
{
    local svlan="$1"
    local cvlan="$2"
    local site="$3"

    if [ "$svlan" = "any" -a "$cvlan" = "any" ]; then
        # Will log "Session qualifier rule (s-vlan `$svlan` c-vlan `$cvlan` site `$site`) is not supported"
        log "Cannot use 'any' as both vlans" ptsd MCD_LOG_SQ_INVALID_QINQ_RULE LOG_ERR "$svlan" "$cvlan" "$site"
        rc_conf_error_occurred=1
        return
    fi

    AddSessionQualifierSetVlanBridgeGroupToSiteMapping "any" "$cvlan" "$site" "$svlan"

    if [ $? -ne 0 ]; then
        # Will log "Session qualifier rule (s-vlan $svlan c-vlan $cvlan site $site) is a duplicate rule"
        log "Duplicate rule detected" ptsd MCD_LOG_SQ_DUPLICATE_QINQ_RULE LOG_ERR "$svlan" "$cvlan" "$site"
        rc_conf_error_occurred=1
        return
    fi

}

# Called by CLI 'set config service session-qualifier bridge-group'
#
# args:
#   1 - Bridge-group (numeric 1..16)
#   2 - site
#
AddSessionQualifierBridgeGroupSiteMapping()
{
    local bridgegroup="$1"
    local site="$2"

    if [ "$bridgegroup" = "any" ]; then
        # Will log "Session qualifier rule (bridge-group `$bridgegroup` site `$site`) is not supported"
        log "Cannot use 'any' as a bridge-group" ptsd MCD_LOG_SQ_INVALID_BG_RULE LOG_ERR "$bridgegroup" "$site"
        rc_conf_error_occurred=1
        return
    fi

    AddSessionQualifierSetVlanBridgeGroupToSiteMapping "$bridgegroup" "any" "$site" "any"

    if [ $? -ne 0 ]; then
        # Will log "Session qualifier rule (bridge-group $bridgegroup site $site) is a duplicate rule"
        log "Duplicate rule detected" ptsd MCD_LOG_SQ_DUPLICATE_BG_RULE LOG_ERR "$bridgegroup" "$site"
        rc_conf_error_occurred=1
        return
    fi

}

# Configuration Parameters related to smooth streaming analyzer 
pdb_smooth_streaming_video_state_timeout="streaming.1.tcpAnalyzers.smoothstreaming.config.storedVideoStateTimeout"
smooth_streaming_video_state_timeout=60

pdb_smooth_streaming_video_state_maximum="streaming.1.tcpAnalyzers.smoothstreaming.config.maxStoredVideoStates"
smooth_streaming_video_state_maximum=10000

# Configuration Parameters related to hls analyzer 
pdb_hls_video_state_timeout="streaming.1.tcpAnalyzers.hls.config.storedVideoStateTimeout"
hls_video_state_timeout=60

pdb_hls_video_state_maximum="streaming.1.tcpAnalyzers.hls.config.maxStoredVideoStates"
hls_video_state_maximum=10000

# Configuration Parameters related to hds analyzer 
pdb_hds_video_state_timeout="streaming.1.tcpAnalyzers.hds.config.storedVideoStateTimeout"
hds_video_state_timeout=60

pdb_hds_video_state_maximum="streaming.1.tcpAnalyzers.hds.config.maxStoredVideoStates"
hds_video_state_maximum=10000

pdb_uniquebyipv6_hash_mask="policy.1.config.uniqueByIpv6Mask"
uniquebyipv6_hash_mask="FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF"

pdb_ld_scalingFactor="policy.1.levelDistribution.config.scalingFactor"
ld_scalingFactor=1

pdb_shape_before_recognition="shaping.1.config.shapeBeforeRecognition"
shape_before_recognition=false

# what is the longest timer, in ms, which a shaper can schedule between packets
pdb_shaping_max_timer="shaping.1.config.maxInstanceTimerMs"
shaping_max_timer=10

# Configuration Parameters related to network protection 
# The max amount of memory in MB
pdb_network_protection_max_memory="networkProtection.1.config.maxMemory"

network_protection_mem_per_million_subs=$(get_config_value MCD_TUNING_PTSD_NP_MEM_PER_MILLION_SUBS)
if [ $? -ne 0 ]; then
    log "The platform type could not be identified" ptsd MCD_LOG_PLATFORM_NOT_RECOGNIZED LOG_ERR 
else
    max_subs=$(get_config_value MCD_TUNING_PTSD_MAX_SUBS)
    np_total_mem=$(( ($network_protection_mem_per_million_subs * $max_subs) / 1000000 ))
    network_protection_max_memory=$(( $np_total_mem / $the_total_ptsd_instances ))
fi

pdb_network_protection_stat_event_period="detectorMgr.1.config.statPeriodSec"
network_protection_stat_event_period=300

pdb_network_protection_max_mitigation_rules="mitigators.1.config.maxMitigationRules"
network_protection_max_mitigation_rules=10000

# POWERVIEW!
pdb_powerview_enabled="powerview.1.config.enabled"
powerview_enabled="false"
pdb_powerview_traffic_capture_enabled="powerview.1.config.traffic.captureEnabled"
powerview_traffic_capture_enabled="true"
pdb_powerview_traffic_detail_enabled="powerview.1.config.traffic.detailEnabled"
powerview_traffic_detail_enabled="true"
pdb_powerview_traffic_query_identity="powerview.1.config.traffic.queryIdentity"
powerview_traffic_query_identity="true"
pdb_powerview_traffic_obfuscate_identity="powerview.1.config.traffic.obfuscateIdentity"
powerview_traffic_obfuscate_identity="false"
pdb_powerview_session_timeout="powerview.1.config.sessionTimeout"
powerview_session_timeout=300
pdb_powerview_session_limit="powerview.1.config.sessionLimit"
powerview_session_limit=2
pdb_powerview_cpu_threshold="powerview.1.config.cpuThreshold"
powerview_cpu_threshold=90
pdb_powerview_memory_threshold="powerview.1.config.memoryThreshold"
powerview_memory_threshold=90
# The default size of the PowerView subscriber session filter is based on the
# maximum number of subscribers.
pdb_powerview_traffic_initial_subscriber_session_filter_capacity="powerview.1.config.traffic.initialSubscriberSessionFilterCapacity"
powerview_traffic_initial_subscriber_session_filter_capacity=$((3 * $max_subscribers))

